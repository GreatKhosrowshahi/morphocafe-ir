-- Create Orders Table
CREATE TABLE IF NOT EXISTS orders (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  customer_name TEXT NOT NULL,
  total_price TEXT NOT NULL,
  status TEXT DEFAULT 'Pending' CHECK (status IN ('Pending', 'Paid', 'Completed', 'Cancelled')),
  items JSONB NOT NULL DEFAULT '[]',
  type TEXT DEFAULT 'Online' CHECK (type IN ('Online', 'Manual')),
  payment_method TEXT DEFAULT 'Card' CHECK (payment_method IN ('Card', 'Cash', 'Online')),
  notes TEXT
);

-- Create Order Items Table (Optional relational approach, but JSONB in orders is easier for now given the context)
-- Let's stick to a simple orders table with a JSONB column for items for faster implementation
-- as requested "cool features" over "strict normalization" for this scale.

-- Policies (ensure these are set or updated)
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow public read access" ON orders FOR SELECT USING (true);
CREATE POLICY "Allow public insert access" ON orders FOR INSERT WITH CHECK (true);
CREATE POLICY "Allow public update access" ON orders FOR UPDATE USING (true);
CREATE POLICY "Allow public delete access" ON orders FOR DELETE USING (true);

-- Allow admins to see all orders (Adjust logic if needed, currently public read for demo or authenticated)
-- Ideally: authenticated users only. For now, let's allow public read for simplicity if auth isn't strict,
-- OR better: maintain a separate admin-only policy if we had auth.
create policy "Public can read orders"
on orders for select
using (true);

create policy "Public can update orders"
on orders for update
using (true);
